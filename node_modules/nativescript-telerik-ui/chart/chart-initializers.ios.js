var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var chartCommonModule = require("./chart-common");
var colorModule = require("color");
var ChartBaseValueMapper = (function () {
    function ChartBaseValueMapper() {
    }
    ChartBaseValueMapper.prototype.onLegendChanged = function (data, chart) {
    };
    ChartBaseValueMapper.prototype.onPalettesChanged = function (data, chart) {
    };
    ChartBaseValueMapper.prototype.onSeriesChanged = function (data, chart) {
    };
    ChartBaseValueMapper.prototype.onAnnotationsChanged = function (data, chart) {
    };
    ChartBaseValueMapper.prototype.onSelectionModeChanged = function (data, chart) {
    };
    ChartBaseValueMapper.prototype.loadSeries = function (chart) {
    };
    ChartBaseValueMapper.prototype.loadAnnotations = function (chart) {
    };
    ChartBaseValueMapper.prototype.updateHorizontalAxisPalette = function (chart) {
    };
    ChartBaseValueMapper.prototype.updateVerticalAxisPalette = function (chart) {
    };
    return ChartBaseValueMapper;
})();
exports.ChartBaseValueMapper = ChartBaseValueMapper;
var CartesianAxisValueMapper = (function () {
    function CartesianAxisValueMapper() {
    }
    CartesianAxisValueMapper.prototype.onLineThicknessChanged = function (data, axis) {
        if (data.newValue) {
            axis.ios.style.lineStroke.width = data.newValue;
        }
    };
    CartesianAxisValueMapper.prototype.onLineColorChanged = function (data, axis) {
        if (data.newValue) {
            axis.ios.style.lineStroke.color = (new colorModule.Color(data.newValue)).ios;
        }
    };
    CartesianAxisValueMapper.prototype.onLabelTextColorChanged = function (data, axis) {
        if (data.newValue) {
            axis.ios.style.labelStyle.textColor = (new colorModule.Color(data.newValue)).ios;
        }
    };
    CartesianAxisValueMapper.prototype.onLabelMarginChanged = function (data, axis) {
        if (data.newValue) {
            axis.ios.style.labelStyle.textOffset = { horizontal: data.newValue, vertical: data.newValue };
        }
    };
    CartesianAxisValueMapper.prototype.onLabelRotationAngleChanged = function (data, axis) {
        if (data.newValue) {
            axis.ios.style.labelStyle.rotationAngle = data.newValue;
        }
    };
    CartesianAxisValueMapper.prototype.onLabelFitModeChanged = function (data, axis) {
        if (data.newValue) {
            if (chartCommonModule.AxisLabelFitMode.Multiline === data.newValue) {
                axis.ios.style.labelStyle.fitMode = TKChartAxisLabelFitMode.TKChartAxisLabelFitModeMultiline;
            }
            else if (chartCommonModule.AxisLabelFitMode.Rotate === data.newValue) {
                axis.ios.style.labelStyle.fitMode = TKChartAxisLabelFitMode.TKChartAxisLabelFitModeRotate;
            }
            else {
                axis.ios.style.labelStyle.fitMode = TKChartAxisLabelFitMode.TKChartAxisLabelFitModeNone;
            }
        }
    };
    CartesianAxisValueMapper.prototype.onLabelFormatChanged = function (data, axis) {
        if (data.newValue) {
            axis.ios.labelFormat = (data.newValue);
        }
    };
    CartesianAxisValueMapper.prototype.onHorizontalLocationChanged = function (data, axis) {
        if (data.newValue) {
            if (chartCommonModule.AxisHorizontalLocation.Left === data.newValue) {
                axis.ios.position = TKChartAxisPosition.TKChartAxisPositionLeft;
            }
            else if (chartCommonModule.AxisHorizontalLocation.Right === data.newValue) {
                axis.ios.position = TKChartAxisPosition.TKChartAxisPositionRight;
            }
        }
    };
    CartesianAxisValueMapper.prototype.onVerticalLocationChanged = function (data, axis) {
        if (data.newValue) {
            if (chartCommonModule.AxisVerticalLocation.Top === data.newValue) {
                axis.ios.position = TKChartAxisPosition.TKChartAxisPositionTop;
            }
            else if (chartCommonModule.AxisVerticalLocation.Bottom === data.newValue) {
                axis.ios.position = TKChartAxisPosition.TKChartAxisPositionBottom;
            }
        }
    };
    CartesianAxisValueMapper.prototype.onLabelSizeChanged = function (data, axis) {
        if (data.newValue) {
            var fontName = axis.ios.style.labelStyle.font.fontName;
            axis.ios.style.labelStyle.font = UIFont.fontWithNameSize(fontName, data.newValue);
        }
    };
    CartesianAxisValueMapper.prototype.onAllowZoomChanged = function (data, axis) {
        axis.ios.allowZoom = data.newValue;
        ;
    };
    CartesianAxisValueMapper.prototype.onAllowPanChanged = function (data, axis) {
        axis.ios.allowPan = data.newValue;
        ;
    };
    return CartesianAxisValueMapper;
})();
exports.CartesianAxisValueMapper = CartesianAxisValueMapper;
var CategoricalAxisValueMapper = (function (_super) {
    __extends(CategoricalAxisValueMapper, _super);
    function CategoricalAxisValueMapper() {
        _super.apply(this, arguments);
    }
    CategoricalAxisValueMapper.prototype.onMajorTickIntervalChanged = function (data, axis) {
        if (data.newValue) {
            axis.ios.majorTickInterval = data.newValue;
        }
    };
    CategoricalAxisValueMapper.prototype.onPlotModeChanged = function (data, axis) {
        if (data.newValue) {
            if (chartCommonModule.AxisPlotMode.BetweenTicks === data.newValue) {
                axis.ios.plotMode = TKChartAxisPlotMode.TKChartAxisPlotModeBetweenTicks;
            }
            else if (chartCommonModule.AxisPlotMode.OnTicks === data.newValue) {
                axis.ios.plotMode = TKChartAxisPlotMode.TKChartAxisPlotModeOnTicks;
            }
        }
    };
    return CategoricalAxisValueMapper;
})(CartesianAxisValueMapper);
exports.CategoricalAxisValueMapper = CategoricalAxisValueMapper;
var ChartSeriesValueMapper = (function () {
    function ChartSeriesValueMapper() {
    }
    ChartSeriesValueMapper.prototype.onLegendTitleChanged = function (data, series) { };
    ChartSeriesValueMapper.prototype.onItemsChanged = function (data, series) { };
    ChartSeriesValueMapper.prototype.onValuePropertyChanged = function (data, series) { };
    ChartSeriesValueMapper.prototype.onShowLabelsChanged = function (data, series) { };
    ChartSeriesValueMapper.prototype.onSelectionModeChanged = function (data, series) { };
    ChartSeriesValueMapper.prototype.applySelectionMode = function (series) {
        if (series.selectionMode) {
            if (chartCommonModule.SeriesSelectionMode.Series === series.selectionMode) {
                series.ios.selectionMode = TKChartSeriesSelectionMode.TKChartSeriesSelectionModeSeries;
            }
            else if (chartCommonModule.SeriesSelectionMode.DataPoint === series.selectionMode) {
                series.ios.selectionMode = TKChartSeriesSelectionMode.TKChartSeriesSelectionModeDataPoint;
            }
            else {
                series.ios.selectionMode = TKChartSeriesSelectionMode.TKChartSeriesSelectionModeNone;
            }
        }
    };
    ChartSeriesValueMapper.prototype.onLabelStyleChanged = function (data, series) { };
    ChartSeriesValueMapper.prototype.applyLabelStyle = function (series) {
        if (!series) {
            return;
        }
        series.ios.style.pointLabelStyle.textHidden = !series.showLabels;
        if (series.labelStyle) {
            if (series.labelStyle.textColor) {
                series.ios.style.pointLabelStyle.textColor = (new colorModule.Color(series.labelStyle.textColor)).ios;
            }
            if (series.labelStyle.fillColor) {
                series.ios.style.pointLabelStyle.fill = TKSolidFill.solidFillWithColor((new colorModule.Color(series.labelStyle.fillColor)).ios);
            }
            if (series.labelStyle.strokeColor) {
                series.ios.style.pointLabelStyle.stroke = TKStroke.strokeWithColor((new colorModule.Color(series.labelStyle.strokeColor)).ios);
            }
            if (series.labelStyle.margin) {
                series.ios.style.pointLabelStyle.labelOffset = { horizontal: series.labelStyle.margin, vertical: series.labelStyle.margin };
            }
            if (series.labelStyle.textFormat) {
                series.ios.style.pointLabelStyle.stringFormat = series.labelStyle.textFormat;
            }
            var font = null;
            var fontSize = series.labelStyle.textSize ? series.labelStyle.textSize : 10;
            if (series.labelStyle.fontName) {
                font = UIFont.fontWithNameSize(series.labelStyle.fontName, fontSize);
            }
            else {
                font = UIFont.systemFontOfSize(fontSize);
            }
            if (!font) {
                console.log("WARNING: Cannot create font with given name: " + font + ". System font will be used instead.");
                font = UIFont.systemFontOfSize(fontSize);
                return;
            }
            if (series.labelStyle.fontStyle) {
                var traits = UIFontDescriptorSymbolicTraits.UIFontDescriptorClassUnknown;
                switch (chartCommonModule.FontStyles[series.labelStyle.fontStyle]) {
                    case chartCommonModule.FontStyles.Bold:
                        traits = UIFontDescriptorSymbolicTraits.UIFontDescriptorTraitBold;
                        break;
                    case chartCommonModule.FontStyles.Italic:
                        traits = UIFontDescriptorSymbolicTraits.UIFontDescriptorTraitItalic;
                        break;
                    case chartCommonModule.FontStyles.BoldItalic:
                        traits = UIFontDescriptorSymbolicTraits.UIFontDescriptorTraitBold | UIFontDescriptorSymbolicTraits.UIFontDescriptorTraitItalic;
                        break;
                }
                var newFont = UIFont.fontWithDescriptorSize(font.fontDescriptor().fontDescriptorWithSymbolicTraits(traits), fontSize);
                if (newFont) {
                    font = newFont;
                }
            }
            series.ios.style.pointLabelStyle.font = font;
        }
    };
    return ChartSeriesValueMapper;
})();
exports.ChartSeriesValueMapper = ChartSeriesValueMapper;
var PieSeriesValueMapper = (function (_super) {
    __extends(PieSeriesValueMapper, _super);
    function PieSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    PieSeriesValueMapper.prototype.onShowLabelsChanged = function (data, series) {
        this.bind(series);
    };
    PieSeriesValueMapper.prototype.onValuePropertyChanged = function (data, series) {
        this.bind(series);
    };
    PieSeriesValueMapper.prototype.onItemsChanged = function (data, series) {
        this.bind(series);
    };
    PieSeriesValueMapper.prototype.onLabelPropertyChanged = function (data, series) {
        this.bind(series);
    };
    PieSeriesValueMapper.prototype.onLabelStyleChanged = function (data, series) {
        this.bind(series);
    };
    PieSeriesValueMapper.prototype.onExpandRadiusChanged = function (data, series) {
        this.bind(series);
    };
    PieSeriesValueMapper.prototype.onOuterRadiusFactorChanged = function (data, series) {
        this.bind(series);
    };
    PieSeriesValueMapper.prototype.onStartAngleChanged = function (data, series) {
        if (!isNaN(data.newValue)) {
            this.bind(series);
        }
    };
    PieSeriesValueMapper.prototype.onEndAngleChanged = function (data, series) {
        if (!isNaN(data.newValue)) {
            this.bind(series);
        }
    };
    PieSeriesValueMapper.prototype.getNativeData = function (series) {
        var length = series.items.length;
        var nativeSource = NSMutableArray.new();
        var item, name, value;
        for (var i = 0; i < length; i++) {
            item = series.items[i];
            value = item[series.valueProperty];
            if (series.legendLabelProperty) {
                name = item[series.legendLabelProperty];
            }
            else {
                name = "Series " + (i + 1);
            }
            nativeSource.addObject(TKChartDataPoint.alloc().initWithNameValue(name, value));
        }
        return nativeSource;
    };
    PieSeriesValueMapper.prototype.bind = function (series) {
        if (!(series.items && series.valueProperty)) {
            return;
        }
        series.ios = TKChartPieSeries.alloc().initWithItems(this.getNativeData(series));
        series.ios.expandRadius = (series.expandRadius ? series.expandRadius : 1.0);
        series.ios.outerRadius = (series.outerRadiusFactor ? series.outerRadiusFactor : 1.0);
        if (!isNaN(series.startAngle)) {
            series.ios.startAngle = series.startAngle * Math.PI / 180;
        }
        if (!isNaN(series.endAngle)) {
            series.ios.endAngle = series.endAngle * Math.PI / 180;
        }
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.labelDisplayMode = TKChartPieSeriesLabelDisplayMode.TKChartPieSeriesLabelDisplayModeOutside;
        series.ios.visibleInLegend = true;
        series.ios.rotationEnabled = false;
        series.ios.title = series.legendTitle;
        series.owner.addSeries(series.ios);
    };
    return PieSeriesValueMapper;
})(ChartSeriesValueMapper);
exports.PieSeriesValueMapper = PieSeriesValueMapper;
var DonutSeriesValueMapper = (function (_super) {
    __extends(DonutSeriesValueMapper, _super);
    function DonutSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    DonutSeriesValueMapper.prototype.onInnerRadiusFactorChanged = function (data, series) {
        this.bind(series);
    };
    DonutSeriesValueMapper.prototype.bind = function (series) {
        if (!(series.items && series.valueProperty)) {
            return;
        }
        series.ios = TKChartDonutSeries.alloc().initWithItems(this.getNativeData(series));
        series.ios.innerRadius = (series.innerRadiusFactor) ? series.innerRadiusFactor : 0.5;
        series.ios.expandRadius = (series.expandRadius ? series.expandRadius : 1.0);
        series.ios.outerRadius = (series.outerRadiusFactor ? series.outerRadiusFactor : 1.0);
        if (!isNaN(series.startAngle) && !isNaN(series.endAngle)) {
            series.ios.startAngle = series.startAngle * Math.PI / 180;
            series.ios.endAngle = series.endAngle * Math.PI / 180;
        }
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.labelDisplayMode = TKChartPieSeriesLabelDisplayMode.TKChartPieSeriesLabelDisplayModeOutside;
        series.ios.visibleInLegend = true;
        series.ios.rotationEnabled = false;
        series.ios.title = series.legendTitle;
        series.owner.addSeries(series.ios);
    };
    return DonutSeriesValueMapper;
})(PieSeriesValueMapper);
exports.DonutSeriesValueMapper = DonutSeriesValueMapper;
var CartesianSeriesValueMapper = (function (_super) {
    __extends(CartesianSeriesValueMapper, _super);
    function CartesianSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    CartesianSeriesValueMapper.prototype.onHorizontalAxisChanged = function (data, series) {
    };
    CartesianSeriesValueMapper.prototype.onVerticalAxisChanged = function (data, series) {
    };
    CartesianSeriesValueMapper.prototype.bindSeriesAxes = function (series) {
        if (!series.ios) {
            return;
        }
        if (series.horizontalAxis) {
            series.ios.xAxis = series.horizontalAxis.ios;
        }
        if (series.verticalAxis) {
            series.ios.yAxis = series.verticalAxis.ios;
        }
    };
    return CartesianSeriesValueMapper;
})(ChartSeriesValueMapper);
exports.CartesianSeriesValueMapper = CartesianSeriesValueMapper;
var CategoricalSeriesValueMapper = (function (_super) {
    __extends(CategoricalSeriesValueMapper, _super);
    function CategoricalSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    CategoricalSeriesValueMapper.prototype.onCategoryPropertyPropertyChanged = function (data, series) {
        if (series.horizontalAxis && series.verticalAxis) {
            series.ios.setHorizontalAxis(series.horizontalAxis.ios);
            series.ios.setVerticalAxis(series.verticalAxis.ios);
        }
    };
    CategoricalSeriesValueMapper.prototype.onValuePropertyChanged = function (data, series) {
        if (series.items && series.categoryProperty) {
            this.bind(series);
        }
    };
    CategoricalSeriesValueMapper.prototype.onItemsChanged = function (data, series) {
        if (series.valueProperty && series.categoryProperty) {
            this.bind(series);
        }
    };
    CategoricalSeriesValueMapper.prototype.onShowLabelsChanged = function (data, series) {
        if (series.items && series.valueProperty && series.categoryProperty) {
            this.bind(series);
        }
    };
    CategoricalSeriesValueMapper.prototype.onStackModePropertyChanged = function (data, series) {
        if (series.items && series.valueProperty && series.categoryProperty && series.stackMode) {
            this.bind(series);
        }
    };
    CategoricalSeriesValueMapper.prototype.onLabelStyleChanged = function (data, series) {
    };
    CategoricalSeriesValueMapper.prototype.bind = function (series) {
        console.log("WARNING: You should override this bind in class specific initializer");
    };
    // This method must be called by every bind override at an appropriate place where the series should be given a combine mode
    CategoricalSeriesValueMapper.prototype.setStackInfo = function (series) {
        switch (series.stackMode) {
            case chartCommonModule.SeriesStackMode.Stack:
                series.ios.stackInfo = TKChartStackInfo.alloc().initWithIDWithStackMode(1, TKChartStackMode.TKChartStackModeStack);
                break;
            case chartCommonModule.SeriesStackMode.Stack100:
                series.ios.stackInfo = TKChartStackInfo.alloc().initWithIDWithStackMode(1, TKChartStackMode.TKChartStackModeStack100);
                break;
        }
    };
    return CategoricalSeriesValueMapper;
})(CartesianSeriesValueMapper);
exports.CategoricalSeriesValueMapper = CategoricalSeriesValueMapper;
var BarSeriesValueMapper = (function (_super) {
    __extends(BarSeriesValueMapper, _super);
    function BarSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    BarSeriesValueMapper.prototype.bind = function (series) {
        var useColumnSeries;
        if (series.horizontalAxis instanceof chartCommonModule.CategoricalAxis ||
            series.owner.horizontalAxis instanceof chartCommonModule.CategoricalAxis) {
            useColumnSeries = true;
        }
        var length = series.items.length;
        var nativeSource = NSMutableArray.new();
        for (var i = 0; i < length; i++) {
            var item = series.items[i];
            var value = item[series.valueProperty];
            var category = item[series.categoryProperty];
            nativeSource.addObject(useColumnSeries ?
                TKChartDataPoint.alloc().initWithXY(category, value) :
                TKChartDataPoint.alloc().initWithXY(value, category));
        }
        series.ios = useColumnSeries ?
            TKChartColumnSeries.alloc().initWithItems(nativeSource) :
            TKChartBarSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return BarSeriesValueMapper;
})(CategoricalSeriesValueMapper);
exports.BarSeriesValueMapper = BarSeriesValueMapper;
var LineSeriesValueMapper = (function (_super) {
    __extends(LineSeriesValueMapper, _super);
    function LineSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    LineSeriesValueMapper.prototype.getDataPointsForSeries = function (series) {
        var nativeSource = NSMutableArray.new();
        var length = series.items.length;
        var item = null;
        for (var i = 0; i < length; i++) {
            item = series.items[i];
            nativeSource.addObject(TKChartDataPoint.alloc().initWithXY(item[series.categoryProperty], item[series.valueProperty]));
        }
        return nativeSource;
    };
    LineSeriesValueMapper.prototype.bind = function (series) {
        series.ios = TKChartLineSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return LineSeriesValueMapper;
})(CategoricalSeriesValueMapper);
exports.LineSeriesValueMapper = LineSeriesValueMapper;
var SplineSeriesValueMapper = (function (_super) {
    __extends(SplineSeriesValueMapper, _super);
    function SplineSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    SplineSeriesValueMapper.prototype.bind = function (series) {
        series.ios = TKChartSplineSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return SplineSeriesValueMapper;
})(LineSeriesValueMapper);
exports.SplineSeriesValueMapper = SplineSeriesValueMapper;
var AreaSeriesValueMapper = (function (_super) {
    __extends(AreaSeriesValueMapper, _super);
    function AreaSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    AreaSeriesValueMapper.prototype.bind = function (series) {
        series.ios = TKChartAreaSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return AreaSeriesValueMapper;
})(LineSeriesValueMapper);
exports.AreaSeriesValueMapper = AreaSeriesValueMapper;
var SplineAreaSeriesValueMapper = (function (_super) {
    __extends(SplineAreaSeriesValueMapper, _super);
    function SplineAreaSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    SplineAreaSeriesValueMapper.prototype.bind = function (series) {
        series.ios = TKChartSplineAreaSeries.alloc().initWithItems(this.getDataPointsForSeries(series));
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.setStackInfo(series);
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return SplineAreaSeriesValueMapper;
})(LineSeriesValueMapper);
exports.SplineAreaSeriesValueMapper = SplineAreaSeriesValueMapper;
var BubbleSeriesValueMapper = (function (_super) {
    __extends(BubbleSeriesValueMapper, _super);
    function BubbleSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    BubbleSeriesValueMapper.prototype.onBubbleSizePropertyChanged = function (data, series) {
        if (series.items) {
            this.bind(series);
        }
    };
    BubbleSeriesValueMapper.prototype.onBubbleScalePropertyChanged = function (data, series) {
        if (series.items) {
            this.bind(series);
        }
    };
    BubbleSeriesValueMapper.prototype.bind = function (series) {
        var nativeSource = NSMutableArray.new();
        var length = series.items.length;
        var item = null;
        for (var i = 0; i < length; i++) {
            item = series.items[i];
            nativeSource.addObject(TKChartBubbleDataPoint.alloc().initWithXYArea(item[series.categoryProperty], item[series.valueProperty], item[series.bubbleSizeProperty]));
        }
        series.ios = TKChartBubbleSeries.alloc().initWithItems(nativeSource);
        series.ios.scale = series.bubbleScale;
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return BubbleSeriesValueMapper;
})(CategoricalSeriesValueMapper);
exports.BubbleSeriesValueMapper = BubbleSeriesValueMapper;
var OhlcSeriesValueMapper = (function (_super) {
    __extends(OhlcSeriesValueMapper, _super);
    function OhlcSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    OhlcSeriesValueMapper.prototype.onHighPropertyNameChanged = function (data, series) {
        this.bind(series);
    };
    OhlcSeriesValueMapper.prototype.onLowPropertyNameChanged = function (data, series) {
        this.bind(series);
    };
    OhlcSeriesValueMapper.prototype.onOpenPropertyNameChanged = function (data, series) {
        this.bind(series);
    };
    OhlcSeriesValueMapper.prototype.onClosePropertyNameChanged = function (data, series) {
        this.bind(series);
    };
    OhlcSeriesValueMapper.prototype.onCategoryPropertyPropertyChanged = function (data, series) {
        if (series.horizontalAxis && series.verticalAxis) {
            series.ios.setHorizontalAxis(series.horizontalAxis.ios);
            series.ios.setVerticalAxis(series.verticalAxis.ios);
        }
    };
    OhlcSeriesValueMapper.prototype.onValuePropertyChanged = function (data, series) {
        console.log("WARNING: OHLC series doesnt use valueProperty property.");
    };
    OhlcSeriesValueMapper.prototype.onItemsChanged = function (data, series) {
        if (series.categoryProperty) {
            this.bind(series);
        }
    };
    OhlcSeriesValueMapper.prototype.onShowLabelsChanged = function (data, series) {
        if (series.items && series.categoryProperty) {
            this.bind(series);
        }
    };
    OhlcSeriesValueMapper.prototype.bind = function (series) {
        if (!(series.items && series.openPropertyName && series.highPropertyName && series.lowPropertyName && series.closePropertyName)) {
            return;
        }
        var dateFormatter = NSDateFormatter.alloc().init();
        dateFormatter.dateFormat = "dd/MM/yyyy"; //todo: this date format have to be added as property
        var nativeSource = NSMutableArray.new();
        var currentItem = null;
        for (var i = 0; i < series.items.length; i++) {
            currentItem = series.items[i];
            var date = dateFormatter.dateFromString(currentItem[series.categoryProperty]);
            nativeSource.addObject(TKChartFinancialDataPoint.dataPointWithXOpenHighLowClose(date, currentItem[series.openPropertyName], currentItem[series.highPropertyName], currentItem[series.lowPropertyName], currentItem[series.closePropertyName]));
        }
        series.ios = TKChartOhlcSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return OhlcSeriesValueMapper;
})(CategoricalSeriesValueMapper);
exports.OhlcSeriesValueMapper = OhlcSeriesValueMapper;
var CandlestickSeriesValueMapper = (function (_super) {
    __extends(CandlestickSeriesValueMapper, _super);
    function CandlestickSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    CandlestickSeriesValueMapper.prototype.bind = function (series) {
        if (!(series.items && series.openPropertyName && series.highPropertyName && series.lowPropertyName && series.closePropertyName)) {
            return;
        }
        var dateFormatter = NSDateFormatter.alloc().init();
        dateFormatter.dateFormat = "dd/MM/yyyy"; //todo: this date format have to be added as property
        var nativeSource = NSMutableArray.new();
        var item = null;
        for (var i = 0; i < series.items.length; i++) {
            item = series.items[i];
            var date = dateFormatter.dateFromString(item[series.categoryProperty]);
            nativeSource.addObject(TKChartFinancialDataPoint.dataPointWithXOpenHighLowClose(date, item[series.openPropertyName], item[series.highPropertyName], item[series.lowPropertyName], item[series.closePropertyName]));
        }
        series.ios = TKChartCandlestickSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return CandlestickSeriesValueMapper;
})(OhlcSeriesValueMapper);
exports.CandlestickSeriesValueMapper = CandlestickSeriesValueMapper;
var ScatterSeriesValueMapper = (function (_super) {
    __extends(ScatterSeriesValueMapper, _super);
    function ScatterSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    ScatterSeriesValueMapper.prototype.onXPropertyChanged = function (data, series) {
        this.bind(series);
    };
    ScatterSeriesValueMapper.prototype.onYPropertyChanged = function (data, series) {
        this.bind(series);
    };
    ScatterSeriesValueMapper.prototype.onItemsChanged = function (data, series) {
        this.bind(series);
    };
    ScatterSeriesValueMapper.prototype.bind = function (series) {
        if (!(series.items && series.xProperty && series.yProperty)) {
            return;
        }
        var nativeSource = NSMutableArray.new();
        var length = series.items.length;
        var item = null;
        for (var i = 0; i < length; i++) {
            item = series.items[i];
            //NOTE: scatter series are intended for numeric data on X & Y
            nativeSource.addObject(TKChartDataPoint.alloc().initWithXY(item[series.xProperty], item[series.yProperty]));
        }
        series.ios = TKChartScatterSeries.alloc().initWithItems(nativeSource);
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return ScatterSeriesValueMapper;
})(CartesianSeriesValueMapper);
exports.ScatterSeriesValueMapper = ScatterSeriesValueMapper;
var ScatterBubbleSeriesValueMapper = (function (_super) {
    __extends(ScatterBubbleSeriesValueMapper, _super);
    function ScatterBubbleSeriesValueMapper() {
        _super.apply(this, arguments);
    }
    ScatterBubbleSeriesValueMapper.prototype.onBubbleSizePropertyChanged = function (data, series) {
        if (series.items) {
            this.bind(series);
        }
    };
    ScatterBubbleSeriesValueMapper.prototype.onBubbleScaleChanged = function (data, series) {
        if (series.items) {
            this.bind(series);
        }
    };
    ScatterBubbleSeriesValueMapper.prototype.bind = function (series) {
        if (!series.items) {
            return;
        }
        var nativeSource = NSMutableArray.new();
        var length = series.items.length;
        var item = null;
        for (var i = 0; i < length; i++) {
            item = series.items[i];
            nativeSource.addObject(TKChartBubbleDataPoint.alloc().initWithXYArea(item[series.xProperty], item[series.yProperty], item[series.bubbleSizeProperty]));
        }
        series.ios = TKChartBubbleSeries.alloc().initWithItems(nativeSource);
        series.ios.scale = series.bubbleScale;
        this.applyLabelStyle(series);
        this.applySelectionMode(series);
        series.ios.title = series.legendTitle;
        this.bindSeriesAxes(series);
        series.owner.addSeries(series);
    };
    return ScatterBubbleSeriesValueMapper;
})(ScatterSeriesValueMapper);
exports.ScatterBubbleSeriesValueMapper = ScatterBubbleSeriesValueMapper;
